{
  parserClass="org.nim.grammar.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="org.nim.psi"
  psiImplPackage="org.nim.psi.impl"

  elementTypeHolderClass="org.nim.psi.NimTokenTypes"
  elementTypeClass="org.nim.psi.NimElementType"
  tokenTypeClass="org.nim.psi.NimTokenType"

  tokens = [
    BLOCK_COMMENT_START="#["
    BLOCK_COMMENT_END="]#"

   ADDR = 'addr'
   AND = 'and'
   AS = 'as'
   ASM = 'asm'
   BIND = 'bind'
   BLOCK = 'block'
   BREAK = 'break'
   CASE = 'case'
   CAST = 'cast'
   CONCEPT ='concept'
   CONSY = 'const'
   CONTINUE = 'continue'
   CONVERTER='converter'
   DEFER='defer'
   DISCARD='discard'
   DISTINCT='distinct'
   DIV='div'
   DO='do'
   ELIF='elif'
   ELSE='else'
   END='end'
   ENUM='enum'
   EXCEPT='except'
   EXPORT='export'
   FINALLY='finally'
   FOR='for'
   FROM='from'
   FUNC='func'
   IF='if'
   IMPORT='import'
   IN='in'
   INCLUDE='include'
   INTERFACE='interface'
   IS='is'
   ISNOT='isnot'
   ITERATOR='iterator'
   LET='let'
   MACRO='macro'
   METHOD='method'
   MIXIN='mixin'
   MOD='mod'
   NIL='nil'
   NOT='not'
   NOTIN='notin'
   OBJECT='object'
   OF='of'
   OR='or'
   OUT='out'
   PROC='proc'
   PTR='ptr'
   RAISE='raise'
   REF='ref'
   RETURN='return'
   SHL='shl'
   SHR='shr'
   STATIC='static'
   TEMPLATE='template'
   TRY='try'
   TUPLE='tuple'
   TYPE='type'
   USING='using'
   VAR='var'
   WHEN='when'
   WHILE='while'
   XOR='xor'
   YIELD='yield'
   PARAN_DOT_OPEN ='(.'
   PARAN_DOT_CLOSE='.)'
   BRACKET_DOT_OPEN='[.'
   BRACKET_DOT_CLOSE='.]'
   CURLY_DOT_OPEN='{.'
   CURLY_DOT_CLOSE='.}'
   PARAN_OPEN='('
   PARAN_CLOSE=')'
   BRACKET_OPEN='['
   BRACKET_CLOSE=']'
   CURLY_OPEN='{'
   CURLY_CLOSE='}'
   COMMA=','
   SEMI_COLON=';'
   DOUBLE_COLON='::'
   SINGLE_COLON=':'
   EQUAL='='
   DOUBLE_DOT='..'
   DOT='.'
   BRACKET_COLON='[:'
   T_OPERATOR
   T_COMMENT
   TILDE='`'
   WHITE_SPACE=' '
    OP_PLUS='+'
    OP_MINUS='-'
    STAR='*'
    OP_FORWAR_SLASH='/'
    OP_BACK_SLASH='\\'
    OP_POINT_LEFT='<'
    OP_POINT_RIGHT='>'
    OP_EXCLAMATION = '!'
    OP_QUSTION ='?'
    OP_CARET='^'
    OP_OR='|'
    OP_PERCENT='%'
    OP_AMP='&'
    OP_DOLLAR='$'
    OP_AT='@'
    OP_TILDE='~'
    OP_COLON=':'
    CRLF='<crlf>'
    RAW_STRING='<raw_string>'
    COMMENT = '<comment>'
  ]
}

File ::= (Procedure| Assignment| HASH | ComparisonStatement| MethodCall | CRLF? )* <<eof>>
ComparisonStatement ::= (WHILE|WHEN|IF) ComparisonCondition SINGLE_COLON
ComparisonCondition ::= (Literal|IDENTIFIER) COMPARISON (Literal|IDENTIFIER)
Procedure ::= PROC (TILDE TILDE_IDENTIFIER TILDE | IDENTIFIER) STAR? GenericType? PARAN_OPEN Arguments PARAN_CLOSE QualifiedType? EQUAL
Assignment ::= VAR IDENTIFIER EQUAL IdentifierOrLiteral
ArrayAccess ::= IDENTIFIER BRACKET_OPEN IdentifierOrLiteral BRACKET_CLOSE
IdentifierOrLiteral ::= ArrayAccess|IDENTIFIER|Literal
Literal ::= Integer | StringLiteral | TripleQuoteString

Integer ::= (SignedInteger|UnsignedInteger)
SignedInteger ::= INTEGER_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
UnsignedInteger ::= UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT

StringLiteral ::= (RAW_STRING | DOUBLE_QUOTE ) STRING_CONTENTS DOUBLE_QUOTE
TripleQuoteString ::= DOUBLE_QUOTE{3} STRING_CONTENTS DOUBLE_QUOTE{3}
QualifiedType ::= IDENTIFIER GenericType?
GenericType ::= BRACKET_OPEN IDENTIFIER (COMMA IDENTIFIER)* BRACKET_CLOSE
Arguments ::= Argument (COMMA Argument)*
Argument ::= IDENTIFIER (COMMA IDENTIFIER)* SINGLE_COLON VAR? QualifiedType ( EQUAL Literal)?


MethodCall ::= IDENTIFIER PARAN_OPEN IdentifierOrLiteral? (COMMA IdentifierOrLiteral)* PARAN_CLOSE