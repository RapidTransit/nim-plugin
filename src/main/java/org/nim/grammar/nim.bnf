{
  parserClass="org.nim.grammar.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="org.nim.psi"
  psiImplPackage="org.nim.psi.impl"

  elementTypeHolderClass="org.nim.psi.NimTokenTypes"
  elementTypeClass="org.nim.psi.NimElementType"
  tokenTypeClass="org.nim.psi.NimTokenType"
  psiImplUtilClass="org.nim.grammar.NimPsiImplUtil"
    parserUtilClass="org.nim.grammar.NimParserUtil"
  tokens = [
    BLOCK_COMMENT_START="#["
    BLOCK_COMMENT_END="]#"
    ADDR = 'addr'
    AND = 'and'
    AS = 'as'
    ASM = 'asm'
    BIND = 'bind'
    BLOCK = 'block'
    BREAK = 'break'
    CASE = 'case'
    CAST = 'cast'
    CONCEPT ='concept'
    CONSY = 'const'
    CONTINUE = 'continue'
    CONVERTER='converter'
    DEFER='defer'
    DISCARD='discard'
    DISTINCT='distinct'
    DIV='div'
    DO='do'
    ELIF='elif'
    ELSE='else'
    END='end'
    ENUM='enum'
    EXCEPT='except'
    EXPORT='export'
    FINALLY='finally'
    FOR='for'
    FROM='from'
    FUNC='func'
    IF='if'
    IMPORT='import'
    IN='in'
    INCLUDE='include'
    INTERFACE='interface'
    IS='is'
    ISNOT='isnot'
    ITERATOR='iterator'
    LET='let'
    MACRO='macro'
    METHOD='method'
    MIXIN='mixin'
    MOD='mod'
    NIL='nil'
    NOT='not'
    NOTIN='notin'
    OBJECT='object'
    OF='of'
    OR='or'
    OUT='out'
    PROC='proc'
    PTR='ptr'
    RAISE='raise'
    REF='ref'
    RETURN='return'
    SHL='shl'
    SHR='shr'
    STATIC='static'
    TEMPLATE='template'
    TRY='try'
    TUPLE='tuple'
    TYPE='type'
    USING='using'
    VAR='var'
    WHEN='when'
    WHILE='while'
    XOR='xor'
    YIELD='yield'
    PARAN_DOT_OPEN ='(.'
    PARAN_DOT_CLOSE='.)'
    BRACKET_DOT_OPEN='[.'
    BRACKET_DOT_CLOSE='.]'
    CURLY_DOT_OPEN='{.'
    CURLY_DOT_CLOSE='.}'
    PARAN_OPEN='('
    PARAN_CLOSE=')'
    BRACKET_OPEN='['
    BRACKET_CLOSE=']'
    CURLY_OPEN='{'
    CURLY_CLOSE='}'
    COMMA=','
    SEMI_COLON=';'
    DOUBLE_COLON='::'
    SINGLE_COLON=':'
    EQUAL='='
    DOUBLE_DOT='..'
    DOT='.'
    BRACKET_COLON='[:'
    BACK_TICK='`'
    WHITE_SPACE=' '
    PLUS='+'
    MINUS='-'
    STAR='*'
    FORWAR_SLASH='/'
    BACK_SLASH='\\'
    LESS_THAN='<'
    GREATER_THAN='>'
    EXCLAMATION = '!'
    QUSTION ='?'
    CARET='^'
    OP_OR='|'
    PERCENT='%'
    AMP='&'
    DOLLAR='$'
    AT='@'
    TILDE='~'
    TILDE_IDENTIFIER='<tilde_identifier>'
    CRLF='<crlf>'
    RAW_STRING='<raw_string>'
    COMMENT = '<comment>'
    INDENT= 'INDENT'
    DOC_RUNNABLE = '<doc_runnable>'
    EXAMPLE = '<example>'
    SINGLE_LINE_COMMENT='<single_line_comment>'
  ]
  extends("(Or|And|Add|At|Conversion|Mul|Selector|Paran|Conditional|If|KW|Spread|Proc)Expression")=BinaryExpression
    extends(".*(Expression|OperandName|Literal)")=Expression
    extends(".*Statement")=Statement
}

File ::= <<beginParsing>> (!<<eof>> TopLevel)* <<eof>>?

private TopLevel ::= ImportSection|TopDeclaration|<<isNotInType>>Statement

ImportSection ::= IMPORT IDENTIFIER (COMMA IDENTIFIER)*

Indentation ::= INDENT <<increaseIndent>>
Dedentation ::= DEDENT <<decreaseIndent>>
Statement ::= <<isNotInType>>( ImportSection | VarDeclaration| SimpleStatement| ReturnStatement | WhileStatement | IfStatement|ForStatement)

ReturnStatement ::= RETURN SimpleStatement?
VarDeclaration ::=
    VAR Vars
    | LET Vars
    | CONST Vars

private Vars ::=
    (Indentation  VarSpec+   Dedentation)
    | ( VarSpec+  )



VarSpec ::= VarDefinitionList  VarDec

private VarDec ::=
    (SINGLE_COLON IDENTIFIER)
    | (SINGLE_COLON IDENTIFIER EQUAL ExpressionList )
    | EQUAL ExpressionList

private VarDefinitionList ::= VarDefinition ( COMMA VarDefinition )*

VarDefinition ::= IDENTIFIER Pragma?

WhileStatement ::= WHILE Expression SINGLE_COLON Indentation Statement* Dedentation
ForStatement ::= FOR Expression [COMMA Expression] SINGLE_COLON Indentation Statement* Dedentation
IfStatement ::= Ifs
private Ifs ::= IfBlockStatement

IfBlockStatement ::= (WHEN|IF) ConditionalBlock ElseIfStatement* ElseStatement?
ConditionalBlock ::= Expression SINGLE_COLON Indentation Statement* Dedentation
ElseIfStatement ::= ELIF ConditionalBlock
ElseStatement ::= ELSE SINGLE_COLON Indentation Statement* Dedentation
Literal ::=  ArrayLiteral | Integer | StringLiteral | Float
TopDeclaration ::= TypeBlock | <<isNotInType>> MethodTypes | WhenDeclaration
BlockDeclaration ::= BLOCK IDENTIFIER SINGLE_COLON MethodBody
WhenDeclaration ::= WHEN IDENTIFIER SINGLE_COLON MethodBody

TypeBlock ::=  TYPE <<beginTypeBlock>>  Indentation TypeDeclaration+ Dedentation <<endTypeBlock>>

private MethodBody ::= Expression |( Indentation (Statement|WhileStatement|IfStatement|BlockDeclaration)* (<<inProcExpression>> PARAN_CLOSE Dedentation | Dedentation))

TypeDeclaration ::=  <<isInType>> OperandName STAR? EQUAL Types Dedentation?

Parameters ::= PParameters

private PParameters ::=
(PARAN_OPEN PARAN_CLOSE)
| PARAN_OPEN (Parameter ((SEMI_COLON|COMMA) Parameter | &PARAN_CLOSE)*) PARAN_CLOSE

ParameterDefault ::= EQUAL? Expression

ReturnType ::= SINGLE_COLON IDENTIFIER Generics?

Pragma ::= CURLY_DOT_OPEN IDENTIFIER (COMMA IDENTIFIER)* CURLY_DOT_CLOSE

// For this: template sortedByIt*(seq1, op: untyped)
ParameterNames ::= IDENTIFIER (COMMA IDENTIFIER)*

Parameter ::= ParameterNames (SINGLE_COLON? VAR? ParameterType? Generics? Pragma? ParameterDefault?)?

private ParameterType ::= Closure | <<inProcExpression>> Expression |  IDENTIFIER

Closure ::= PROC Parameters  ReturnType? Pragma?
private MethodTypes ::=
    ProcedureMethod
    | TemplateMethod
    | FuncMethod



private Signature ::= IdentifierOrOperator? STAR? Generics? Parameters ReturnType? Pragma? EQUAL

ProcedureMethod ::= PROC Signature MethodBody
FuncMethod ::= FUNC Signature MethodBody
TemplateMethod ::= TEMPLATE Signature MethodBody

Generics ::= BRACKET_OPEN Expression GenericsAdditional? BRACKET_CLOSE
GenericsAdditional ::= COMMA Expression

private IdentifierOrOperator ::= IDENTIFIER | (BACK_TICK BACK_TICK_IDENTIFIER BACK_TICK)

private Types ::= EnumDeclaration | ObjectType

ObjectType ::= REF? (OBJECT | OperandName)  Indentation? ObjectFields+

ObjectField ::= IDENTIFIER STAR?
ObjectFields ::= ObjectField (COMMA ObjectField)* SINGLE_COLON REF? OperandName

EnumDeclaration ::= ENUM Indentation OperandName (COMMA OperandName)*

Integer ::= (SignedInteger|UnsignedInteger)
Float ::= FLOAT_LIT | FLOAT32_LIT| FLOAT64_LIT
SignedInteger ::= INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
UnsignedInteger ::= UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT

ArrayLiteral ::= BRACKET_OPEN (Expression (COMMA Expression)*)? BRACKET_CLOSE

OperandName ::= ReferenceExpression QualifiedReferenceExpression? {elementType=ReferenceExpression}
left QualifiedReferenceExpression ::= DOT IDENTIFIER {elementType=ReferenceExpression}
ReferenceExpression::= IDENTIFIER { extends=Expression}

StringLiteral ::= DoubleQuotedStringLiteral | RawStringLiteral | TripleQuoteStringLiteral

DoubleQuotedStringLiteral ::= DOUBLE_QUOTED_LITERAL
RawStringLiteral ::= RAW_STRING
TripleQuoteStringLiteral ::= TRIPLE_DOUBLE_STR


fake BinaryExpression ::= Expression+ {
  methods=[left="Expression[0]" right="Expression[1]" ]
}
UnaryExpression ::= UnaryOp Expression
UnaryOp ::= MINUS
SimpleStatement ::= UMethodExpressionOrLeftHand

private UMethodExpressionOrLeftHand ::= LeftHandExprList [AssignmentStatement | SimpleStatement]

left AssignmentStatement ::= AssignmentOp ExpressionList

private AssignmentOp ::= MINUS_ASSIGN | PLUS_ASSIGN | EQUAL

LeftHandExprList ::= ExpressionList


private ExpressionArgList ::= Expression (COMMA Expression)*
private ExpressionList ::= Expression (COMMA Expression)*


Expression ::=
    AtExpression
    | AndExpression
    | OrExpression
    | ConditionalExpression
    | MultiplyExpression
    | AddExpression
    | SpreadExpression
    | UnaryExpression
    | ProcExpression
    | MaxGroup
    | Op7Expression
    | IfExpression
    | ParanExpression

ProcExpression ::= PROC <<startProcExpression>> Signature MethodBody <<endProcExpression>> { extends=Expression}
IfExpression ::= IF (UranaryConditionalExpression | ConditionalExpression) SINGLE_COLON  (RETURN | Expression)
private MaxGroup ::= OperandName
| IndexOrSliceExpression
| CallExpression

| Literal


private ConditionalsExpression ::=
    

AndExpression ::= Expression OP6 Expression
AtExpression ::= AT Expression
SpreadExpression ::= Expression OP4 Expression
OrExpression ::= Expression OR Expression
UranaryConditionalExpression ::= NOT Expression
ConditionalExpression ::=  Expression OP5 Expression
MultiplyExpression ::= Expression OP1 Expression
AddExpression ::= Expression OP2 Expression
ParanExpression ::= !Expression PARAN_OPEN <<enterMode "PAR">>  Expression <<exitModeSafe "PAR">> PARAN_CLOSE
Op7Expression ::= Expression OP7 Expression
IndexOrSliceExpression ::= Expression BRACKET_OPEN IndexExprBody BRACKET_CLOSE
private IndexExprBody ::= Expression
CallExpression ::= Expression Generics? ArgumentList
ArgumentList ::= PARAN_OPEN <<enterMode "CALL">>  ExpressionArgList? <<exitModeSafe "CALL">> PARAN_CLOSE
Operator ::=
    OP0
    | OP1
    | OP2
    | OP3
    | OP4
    | OP5
    | OP6
    | OP7
    | OP8

private OP0 ::=
    DOLLAR
    | CARET

private OP1 ::=
    STAR
    | FORWAR_SLASH
    | DIV
    | MOD
    | SHL
    | SHR

private OP2 ::=
    PLUS
    | MINUS

private OP3 ::= AMP

private OP4 ::= DOUBLE_DOT

private OP5 ::=
    EQUALS
    | LT_EQUAL
    | LESS_THAN
    | GREATER_THAN
    | GT_EQUAL
    | NOT_EQUAL
    | IN
    | NOTIN
    | IS
    | ISNOT
    | OF
    | NOT

private OP6 ::= AND

private OP7 ::=
      OR
     | AND
     | XOR

private OP8 ::=
     AT
     | SINGLE_COLON
     | QUSTION
