Nim file
  PsiComment(NimTokenType.<single_line_comment>)('#')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#            Nim's Runtime Library')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#        (c) Copyright 2015 Andreas Rumpf')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#    See the file "copying.txt", included in this')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#    distribution, for details about the copyright.')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('#')
  PsiWhiteSpace('\n')
  PsiWhiteSpace('\n')
  PsiComment(NimTokenType.<single_line_comment>)('## This module implements some common generic algorithms.')
  PsiWhiteSpace('\n')
  PsiWhiteSpace('\n')
  PsiElement(NimTokenType.type)('type')
  PsiElement(NimTokenType.INDENT)('\n  ')
  PsiElement(NimTokenType.IDENTIFIER)('SortOrder')
  PsiElement(NimTokenType.*)('*')
  PsiWhiteSpace(' ')
  PsiElement(NimTokenType.=)('=')
  PsiWhiteSpace(' ')
  PsiElement(NimTokenType.enum)('enum')
  PsiElement(NimTokenType.INDENT)('\n    ')
  PsiElement(NimTokenType.IDENTIFIER)('Descending')
  PsiElement(NimTokenType.,)(',')
  PsiWhiteSpace(' ')
  PsiElement(NimTokenType.IDENTIFIER)('Ascending')
  PsiWhiteSpace('\n')
  PsiElement(NimTokenType.DEDENT)('\n')
  PsiErrorElement:NimTokenType.DEDENT expected, got 'proc'
    PsiElement(NimTokenType.proc)('proc')
  PsiElement(DUMMY_BLOCK)
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.~)('`')
      PsiElement(NimTokenType.<tilde_identifier>)('*')
      PsiElement(NimTokenType.~)('`')
      PsiElement(NimTokenType.*)('*')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('int')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('order')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('SortOrder')
      PsiElement(NimTokenType.))(')')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('int')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.{.)('{.')
      PsiElement(NimTokenType.IDENTIFIER)('inline')
      PsiElement(NimTokenType..})('.}')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiElement(NimTokenType.INDENT)('\n  ')
    PsiElement(DUMMY_BLOCK)
      PsiComment(NimTokenType.<single_line_comment>)('## flips ``x`` if ``order == Descending``.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.<single_line_comment>)('## If ``order == Ascending`` then ``x`` is returned.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.<single_line_comment>)('##')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.<single_line_comment>)('## ``x`` is supposed to be the result of a comparator, i.e.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.<single_line_comment>)('## | ``< 0`` for *less than*,')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.<single_line_comment>)('## | ``== 0`` for *equal*,')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.<single_line_comment>)('## | ``> 0`` for *greater than*.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('order')
      PsiElement(NimTokenType..)('.')
      PsiElement(NimTokenType.IDENTIFIER)('ord')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.-)('-')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.INT_LIT)('1')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('result')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.xor)('xor')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.-)('-')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiWhiteSpace('\n')
      PsiElement(NimTokenType.DEDENT)('\n')
      PsiElement(NimTokenType.template)('template')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('fillImpl')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('openArray')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('int')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('value')
      PsiElement(NimTokenType.:)(':')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiElement(NimTokenType.INDENT)('\n  ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.while)('while')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('x')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.LT_EQUAL)('<=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiElement(NimTokenType.:)(':')
      PsiElement(NimTokenType.INDENT)('\n    ')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiElement(NimTokenType.])(']')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('value')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('inc')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace('\n')
      PsiElement(NimTokenType.DEDENT)('\n')
      PsiElement(NimTokenType.proc)('proc')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('fill')
      PsiElement(NimTokenType.*)('*')
      PsiElement(NimTokenType.[)('[')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('openArray')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
  PsiElement(DUMMY_BLOCK)
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('Natural')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('value')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiElement(NimTokenType.INDENT)('\n  ')
      PsiComment(NimTokenType.<single_line_comment>)('## fills the slice ``a[first..last]`` with ``value``.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.EXAMPLE)('runnableExamples:')
      PsiElement(NimTokenType.INDENT)('\n      ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('var a: array[6, int]')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('a.fill(1, 3, 9)')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('doAssert a == [0, 9, 9, 9, 0, 0]')
      PsiElement(NimTokenType.DEDENT)('\n  ')
      PsiElement(NimTokenType.IDENTIFIER)('fillImpl')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.,)(',')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('value')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace('\n')
      PsiElement(NimTokenType.DEDENT)('\n')
      PsiElement(NimTokenType.proc)('proc')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('fill')
      PsiElement(NimTokenType.*)('*')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('openArray')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('value')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiElement(NimTokenType.INDENT)('\n  ')
      PsiComment(NimTokenType.<single_line_comment>)('## fills the container ``a`` with ``value``.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.EXAMPLE)('runnableExamples:')
      PsiElement(NimTokenType.INDENT)('\n      ')
    PsiElement(DUMMY_BLOCK)
      PsiComment(NimTokenType.DOC_RUNNABLE)('var a: array[6, int]')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('a.fill(9)')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('doAssert a == [9, 9, 9, 9, 9, 9]')
      PsiElement(NimTokenType.DEDENT)('\n  ')
      PsiElement(NimTokenType.IDENTIFIER)('fillImpl')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.INT_LIT)('0')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType..)('.')
      PsiElement(NimTokenType.IDENTIFIER)('high')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('value')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace('\n')
      PsiWhiteSpace('\n')
      PsiElement(NimTokenType.DEDENT)('\n')
      PsiElement(NimTokenType.proc)('proc')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('reverse')
      PsiElement(NimTokenType.*)('*')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('openArray')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('Natural')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiElement(NimTokenType.INDENT)('\n  ')
      PsiComment(NimTokenType.<single_line_comment>)('## reverses the slice ``a[first..last]``.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.EXAMPLE)('runnableExamples:')
      PsiElement(NimTokenType.INDENT)('\n      ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('var a = [1, 2, 3, 4, 5, 6]')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('a.reverse(1, 3)')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('doAssert a == [1, 4, 3, 2, 5, 6]')
      PsiElement(NimTokenType.DEDENT)('\n  ')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.while)('while')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('x')
  PsiElement(DUMMY_BLOCK)
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.<)('<')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiElement(NimTokenType.:)(':')
      PsiElement(NimTokenType.INDENT)('\n    ')
      PsiElement(NimTokenType.IDENTIFIER)('swap')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiElement(NimTokenType.])(']')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('dec')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('y')
      PsiElement(NimTokenType.))(')')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('inc')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('x')
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace('\n')
      PsiElement(NimTokenType.DEDENT)('\n')
      PsiElement(NimTokenType.proc)('proc')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('reverse')
      PsiElement(NimTokenType.*)('*')
      PsiElement(NimTokenType.[)('[')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.var)('var')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('openArray')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
      PsiElement(NimTokenType.INDENT)('\n  ')
      PsiComment(NimTokenType.<single_line_comment>)('## reverses the contents of the container ``a``.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.EXAMPLE)('runnableExamples:')
      PsiElement(NimTokenType.INDENT)('\n      ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('var a = [1, 2, 3, 4, 5, 6]')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('a.reverse()')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('doAssert  a == [6, 5, 4, 3, 2, 1]')
      PsiElement(NimTokenType.DEDENT)('\n  ')
      PsiElement(NimTokenType.IDENTIFIER)('reverse')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType.,)(',')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.INT_LIT)('0')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('max')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.INT_LIT)('0')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('a')
      PsiElement(NimTokenType..)('.')
      PsiElement(NimTokenType.IDENTIFIER)('high')
      PsiElement(NimTokenType.))(')')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.))(')')
      PsiWhiteSpace('\n')
      PsiElement(NimTokenType.DEDENT)('\n')
      PsiElement(NimTokenType.proc)('proc')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('reversed')
      PsiElement(NimTokenType.*)('*')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.()('(')
      PsiElement(NimTokenType.IDENTIFIER)('a')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('openArray')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiElement(NimTokenType.,)(',')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('Natural')
      PsiElement(NimTokenType.,)(',')
    PsiElement(DUMMY_BLOCK)
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('int')
      PsiElement(NimTokenType.))(')')
      PsiElement(NimTokenType.:)(':')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('seq')
      PsiElement(NimTokenType.[)('[')
      PsiElement(NimTokenType.IDENTIFIER)('T')
      PsiElement(NimTokenType.])(']')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.=)('=')
    PsiElement(DUMMY_BLOCK)
      PsiElement(NimTokenType.INDENT)('\n  ')
      PsiComment(NimTokenType.<single_line_comment>)('## returns the reverse of the slice ``a[first..last]``.')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.EXAMPLE)('runnableExamples:')
      PsiElement(NimTokenType.INDENT)('\n      ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('let')
      PsiElement(NimTokenType.INDENT)('\n        ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('a = [1, 2, 3, 4, 5, 6]')
      PsiWhiteSpace('\n')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiWhiteSpace(' ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('b = reversed(a, 1, 3)')
      PsiElement(NimTokenType.DEDENT)('\n      ')
      PsiComment(NimTokenType.DOC_RUNNABLE)('doAssert b == @[4, 3, 2]')
      PsiElement(NimTokenType.DEDENT)('\n  ')
      PsiElement(NimTokenType.IDENTIFIER)('assert')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('last')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.GT_EQUAL)('>=')
      PsiWhiteSpace(' ')
      PsiElement(NimTokenType.IDENTIFIER)('first')
  PsiElement(DUMMY_BLOCK)
    PsiElement(NimTokenType.-)('-')
    PsiElement(NimTokenType.INT_LIT)('1')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.var)('var')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('i')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.=)('=')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('last')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.-)('-')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('first')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.var)('var')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('x')
  PsiElement(DUMMY_BLOCK)
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.=)('=')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('first')
    PsiElement(NimTokenType..)('.')
    PsiElement(NimTokenType.IDENTIFIER)('int')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('result')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.=)('=')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('newSeq')
    PsiElement(NimTokenType.[)('[')
    PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(NimTokenType.])(']')
  PsiElement(DUMMY_BLOCK)
    PsiElement(NimTokenType.()('(')
    PsiElement(NimTokenType.IDENTIFIER)('i')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.+)('+')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.INT_LIT)('1')
    PsiElement(NimTokenType.))(')')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.while)('while')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('i')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.GT_EQUAL)('>=')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.INT_LIT)('0')
    PsiElement(NimTokenType.:)(':')
  PsiElement(DUMMY_BLOCK)
    PsiElement(NimTokenType.INDENT)('\n    ')
    PsiElement(NimTokenType.IDENTIFIER)('result')
    PsiElement(NimTokenType.[)('[')
    PsiElement(NimTokenType.IDENTIFIER)('i')
    PsiElement(NimTokenType.])(']')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.=)('=')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('a')
    PsiElement(NimTokenType.[)('[')
    PsiElement(NimTokenType.IDENTIFIER)('x')
    PsiElement(NimTokenType.])(']')
  PsiElement(DUMMY_BLOCK)
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('dec')
    PsiElement(NimTokenType.()('(')
    PsiElement(NimTokenType.IDENTIFIER)('i')
    PsiElement(NimTokenType.))(')')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('inc')
    PsiElement(NimTokenType.()('(')
    PsiElement(NimTokenType.IDENTIFIER)('x')
    PsiElement(NimTokenType.))(')')
    PsiWhiteSpace('\n')
    PsiElement(NimTokenType.DEDENT)('\n')
  PsiElement(DUMMY_BLOCK)
    PsiElement(NimTokenType.proc)('proc')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('reversed')
    PsiElement(NimTokenType.*)('*')
    PsiElement(NimTokenType.[)('[')
    PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(NimTokenType.])(']')
    PsiElement(NimTokenType.()('(')
    PsiElement(NimTokenType.IDENTIFIER)('a')
    PsiElement(NimTokenType.:)(':')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('openArray')
  PsiElement(DUMMY_BLOCK)
    PsiElement(NimTokenType.[)('[')
    PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(NimTokenType.])(']')
    PsiElement(NimTokenType.))(')')
    PsiElement(NimTokenType.:)(':')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('seq')
    PsiElement(NimTokenType.[)('[')
    PsiElement(NimTokenType.IDENTIFIER)('T')
    PsiElement(NimTokenType.])(']')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.=)('=')
  PsiElement(DUMMY_BLOCK)
    PsiElement(NimTokenType.INDENT)('\n  ')
    PsiComment(NimTokenType.<single_line_comment>)('## returns the reverse of the container ``a``.')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.EXAMPLE)('runnableExamples:')
    PsiElement(NimTokenType.INDENT)('\n      ')
    PsiComment(NimTokenType.DOC_RUNNABLE)('let')
    PsiElement(NimTokenType.INDENT)('\n        ')
    PsiComment(NimTokenType.DOC_RUNNABLE)('a = [1, 2, 3, 4, 5, 6]')
    PsiWhiteSpace('\n')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiWhiteSpace(' ')
    PsiComment(NimTokenType.DOC_RUNNABLE)('b = reversed(a)')
    PsiElement(NimTokenType.DEDENT)('\n      ')
    PsiComment(NimTokenType.DOC_RUNNABLE)('doAssert b == @[6, 5, 4, 3, 2, 1]')
    PsiElement(NimTokenType.DEDENT)('\n  ')
    PsiElement(NimTokenType.IDENTIFIER)('reversed')
    PsiElement(NimTokenType.()('(')
    PsiElement(NimTokenType.IDENTIFIER)('a')
    PsiElement(NimTokenType.,)(',')
  PsiElement(DUMMY_BLOCK)
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.INT_LIT)('0')
    PsiElement(NimTokenType.,)(',')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('a')
    PsiElement(NimTokenType..)('.')
    PsiElement(NimTokenType.IDENTIFIER)('high')
    PsiElement(NimTokenType.))(')')
    PsiWhiteSpace('\n')
    PsiElement(NimTokenType.DEDENT)('\n')
    PsiElement(NimTokenType.proc)('proc')
    PsiWhiteSpace(' ')
    PsiElement(NimTokenType.IDENTIFIER)('binarySearch')
    PsiElement(NimTokenType.*)('*')
  PsiElement(NimTokenType.[)('[')
  PsiElement(NimTokenType.IDENTIFIER)('T')
  PsiElement(BAD_CHARACTER)(', K](a: openArray[T], key: K,\n              cmp: proc (x: T, y: K): int {.closure.}): int =\n  ## Binary search for ``key`` in ``a``. Returns -1 if not found.\n  ##\n  ## ``cmp`` is the comparator function to use, the expected return values are\n  ## the same as that of system.cmp.\n  if a.len == 0:\n    return -1\n\n  let len = a.len\n\n  if len == 1:\n    if cmp(a[0], key) == 0:\n      return 0\n    else:\n      return -1\n\n  if (len and (len - 1)) == 0:\n    # when `len` is a power of 2, a faster shr can be used.\n    var step = len shr 1\n    var cmpRes: int\n    while step > 0:\n      let i = result or step\n      cmpRes = cmp(a[i], key)\n      if cmpRes == 0:\n        return i\n\n      if cmpRes < 1:\n        result = i\n      step = step shr 1\n    if cmp(a[result], key) != 0: result = -1\n  else:\n    var b = len\n    var cmpRes: int\n    while result < b:\n      var mid = (result + b) shr 1\n      cmpRes = cmp(a[mid], key)\n      if cmpRes == 0:\n        return mid\n\n      if cmpRes < 0:\n        result = mid + 1\n      else:\n        b = mid\n    if result >= len or cmp(a[result], key) != 0: result = -1\n\nproc binarySearch*[T](a: openArray[T], key: T): int =\n  ## Binary search for ``key`` in ``a``. Returns -1 if not found.\n  binarySearch(a, key, cmp[T])\n\nproc smartBinarySearch*[T](a: openArray[T], key: T): int {.deprecated.} =\n  ## **Deprecated since version 0.18.1**; Use ``binarySearch`` instead.\n  binarySearch(a, key, cmp[T])\n\nconst\n  onlySafeCode = true\n\nproc lowerBound*[T, K](a: openArray[T], key: K, cmp: proc(x: T, k: K): int {.closure.}): int =\n  ## returns a position to the first element in the ``a`` that is greater than\n  ## ``key``, or last if no such element is found.\n  ## In other words if you have a sorted sequence and you call\n  ## ``insert(thing, elm, lowerBound(thing, elm))``\n  ## the sequence will still be sorted.\n  ##\n  ## The first version uses ``cmp`` to compare the elements.\n  ## The expected return values are the same as that of ``system.cmp``.\n  ## The second version uses the default comparison function ``cmp``.\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   var arr = @[1,2,3,5,6,7,8,9]\n  ##   arr.insert(4, arr.lowerBound(4))\n  ##   # after running the above arr is `[1,2,3,4,5,6,7,8,9]`\n  result = a.low\n  var count = a.high - a.low + 1\n  var step, pos: int\n  while count != 0:\n    step = count shr 1\n    pos = result + step\n    if cmp(a[pos], key) < 0:\n      result = pos + 1\n      count -= step + 1\n    else:\n      count = step\n\nproc lowerBound*[T](a: openArray[T], key: T): int = lowerBound(a, key, cmp[T])\n\nproc upperBound*[T, K](a: openArray[T], key: K, cmp: proc(x: T, k: K): int {.closure.}): int =\n  ## returns a position to the first element in the ``a`` that is not less\n  ## (i.e. greater or equal to) than ``key``, or last if no such element is found.\n  ## In other words if you have a sorted sequence and you call\n  ## ``insert(thing, elm, upperBound(thing, elm))``\n  ## the sequence will still be sorted.\n  ##\n  ## The first version uses ``cmp`` to compare the elements. The expected\n  ## return values are the same as that of ``system.cmp``.\n  ## The second version uses the default comparison function ``cmp``.\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   var arr = @[1,2,3,4,6,7,8,9]\n  ##   arr.insert(5, arr.upperBound(4))\n  ##   # after running the above arr is `[1,2,3,4,5,6,7,8,9]`\n  result = a.low\n  var count = a.high - a.low + 1\n  var step, pos: int\n  while count != 0:\n    step = count shr 1\n    pos = result + step\n    if cmp(a[pos], key) <= 0:\n      result = pos + 1\n      count -= step + 1\n    else:\n      count = step\n\nproc upperBound*[T](a: openArray[T], key: T): int = upperBound(a, key, cmp[T])\n\ntemplate `<-` (a, b) =\n  when false:\n    a = b\n  elif onlySafeCode:\n    shallowCopy(a, b)\n  else:\n    copyMem(addr(a), addr(b), sizeof(T))\n\nproc merge[T](a, b: var openArray[T], lo, m, hi: int,\n              cmp: proc (x, y: T): int {.closure.}, order: SortOrder) =\n  # optimization: If max(left) <= min(right) there is nothing to do!\n  # 1 2 3 4  ## 5 6 7 8\n  # -> O(n) for sorted arrays.\n  # On random data this safes up to 40% of merge calls\n  if cmp(a[m], a[m+1]) * order <= 0: return\n  var j = lo\n  # copy a[j..m] into b:\n  assert j <= m\n  when onlySafeCode:\n    var bb = 0\n    while j <= m:\n      b[bb] <- a[j]\n      inc(bb)\n      inc(j)\n  else:\n    copyMem(addr(b[0]), addr(a[j]), sizeof(T)*(m-j+1))\n    j = m+1\n  var i = 0\n  var k = lo\n  # copy proper element back:\n  while k < j and j <= hi:\n    if cmp(b[i], a[j]) * order <= 0:\n      a[k] <- b[i]\n      inc(i)\n    else:\n      a[k] <- a[j]\n      inc(j)\n    inc(k)\n  # copy rest of b:\n  when onlySafeCode:\n    while k < j:\n      a[k] <- b[i]\n      inc(k)\n      inc(i)\n  else:\n    if k < j: copyMem(addr(a[k]), addr(b[i]), sizeof(T)*(j-k))\n\nfunc sort*[T](a: var openArray[T],\n              cmp: proc (x, y: T): int {.closure.},\n              order = SortOrder.Ascending) =\n  ## Default Nim sort (an implementation of merge sort). The sorting\n  ## is guaranteed to be stable and the worst case is guaranteed to\n  ## be O(n log n).\n  ## The current implementation uses an iterative\n  ## mergesort to achieve this. It uses a temporary sequence of\n  ## length ``a.len div 2``. If you do not wish to provide your own\n  ## ``cmp``, you may use ``system.cmp`` or instead call the overloaded\n  ## version of ``sort``, which uses ``system.cmp``.\n  ##\n  ## .. code-block:: nim\n  ##\n  ##    sort(myIntArray, system.cmp[int])\n  ##\n  ##    # do not use cmp[string] here as we want to use the specialized\n  ##    # overload:\n  ##    sort(myStrArray, system.cmp)\n  ##\n  ## You can inline adhoc comparison procs with the `do notation\n  ## <manual.html#procedures-do-notation>`_. Example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   people.sort do (x, y: Person) -> int:\n  ##     result = cmp(x.surname, y.surname)\n  ##     if result == 0:\n  ##       result = cmp(x.name, y.name)\n  var n = a.len\n  var b: seq[T]\n  newSeq(b, n div 2)\n  var s = 1\n  while s < n:\n    var m = n-1-s\n    while m >= 0:\n      merge(a, b, max(m-s+1, 0), m, m+s, cmp, order)\n      dec(m, s*2)\n    s = s*2\n\nproc sort*[T](a: var openArray[T], order = SortOrder.Ascending) = sort[T](a, system.cmp[T], order)\n  ## Shortcut version of ``sort`` that uses ``system.cmp[T]`` as the comparison function.\n\nproc sorted*[T](a: openArray[T], cmp: proc(x, y: T): int {.closure.},\n                order = SortOrder.Ascending): seq[T] =\n  ## returns ``a`` sorted by ``cmp`` in the specified ``order``.\n  runnableExamples:\n      let\n        a = [2, 3, 1, 5, 4]\n        b = sorted(a, system.cmp)\n        c = sorted(a, system.cmp, Descending)\n      doAssert b == @[1, 2, 3, 4, 5]\n      doAssert c == @[5, 4, 3, 2, 1]\n  result = newSeq[T](a.len)\n  for i in 0 .. a.high:\n    result[i] = a[i]\n  sort(result, cmp, order)\n\nproc sorted*[T](a: openArray[T], order = SortOrder.Ascending): seq[T] =\n  ## Shortcut version of ``sorted`` that uses ``system.cmp[T]`` as the comparison function.\n  sorted[T](a, system.cmp[T], order)\n\ntemplate sortedByIt*(seq1, op: untyped): untyped =\n  ## Convenience template around the ``sorted`` proc to reduce typing.\n  ##\n  ## The template injects the ``it`` variable which you can use directly in an\n  ## expression. Example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   type Person = tuple[name: string, age: int]\n  ##   var\n  ##     p1: Person = (name: "p1", age: 60)\n  ##     p2: Person = (name: "p2", age: 20)\n  ##     p3: Person = (name: "p3", age: 30)\n  ##     p4: Person = (name: "p4", age: 30)\n  ##     people = @[p1,p2,p4,p3]\n  ##\n  ##   echo people.sortedByIt(it.name)\n  ##\n  ## Because the underlying ``cmp()`` is defined for tuples you can do\n  ## a nested sort like in the following example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   echo people.sortedByIt((it.age, it.name))\n  ##\n  var result = sorted(seq1, proc(x, y: type(seq1[0])): int =\n    var it {.inject.} = x\n    let a = op\n    it = y\n    let b = op\n    result = cmp(a, b))\n  result\n\nfunc isSorted*[T](a: openArray[T],\n                 cmp: proc(x, y: T): int {.closure.},\n                 order = SortOrder.Ascending): bool =\n  ## checks to see whether ``a`` is already sorted in ``order``\n  ## using ``cmp`` for the comparison. Parameters identical\n  ## to ``sort``.\n  result = true\n  for i in 0..<len(a)-1:\n    if cmp(a[i],a[i+1]) * order > 0:\n      return false\n\nproc isSorted*[T](a: openarray[T], order = SortOrder.Ascending): bool =\n  ## Shortcut version of ``isSorted`` that uses ``system.cmp[T]`` as the comparison function.\n  isSorted(a, system.cmp[T], order)\n\nproc product*[T](x: openArray[seq[T]]): seq[seq[T]] =\n  ## produces the Cartesian product of the array. Warning: complexity\n  ## may explode.\n  result = newSeq[seq[T]]()\n  if x.len == 0:\n    return\n  if x.len == 1:\n    result = @x\n    return\n  var\n    indexes = newSeq[int](x.len)\n    initial = newSeq[int](x.len)\n    index = 0\n  var next = newSeq[T]()\n  next.setLen(x.len)\n  for i in 0..(x.len-1):\n    if len(x[i]) == 0: return\n    initial[i] = len(x[i])-1\n  indexes = initial\n  while true:\n    while indexes[index] == -1:\n      indexes[index] = initial[index]\n      index += 1\n      if index == x.len: return\n      indexes[index] -= 1\n    for ni, i in indexes:\n      next[ni] = x[ni][i]\n    var res: seq[T]\n    shallowCopy(res, next)\n    result.add(res)\n    index = 0\n    indexes[index] -= 1\n\nproc nextPermutation*[T](x: var openarray[T]): bool {.discardable.} =\n  ## calculates the next lexicographic permutation, directly modifying ``x``.\n  ## The result is whether a permutation happened, otherwise we have reached\n  ## the last-ordered permutation.\n  ##\n  ## .. code-block:: nim\n  ##\n  ##     var v = @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  ##     v.nextPermutation()\n  ##     echo v # @[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]\n  if x.len < 2:\n    return false\n\n  var i = x.high\n  while i > 0 and x[i-1] >= x[i]:\n    dec i\n\n  if i == 0:\n    return false\n\n  var j = x.high\n  while j >= i and x[j] <= x[i-1]:\n    dec j\n\n  swap x[j], x[i-1]\n  x.reverse(i, x.high)\n\n  result = true\n\nproc prevPermutation*[T](x: var openarray[T]): bool {.discardable.} =\n  ## calculates the previous lexicographic permutation, directly modifying\n  ## ``x``. The result is whether a permutation happened, otherwise we have\n  ## reached the first-ordered permutation.\n  ##\n  ## .. code-block:: nim\n  ##\n  ##     var v = @[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]\n  ##     v.prevPermutation()\n  ##     echo v # @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  if x.len < 2:\n    return false\n\n  var i = x.high\n  while i > 0 and x[i-1] <= x[i]:\n    dec i\n\n  if i == 0:\n    return false\n\n  x.reverse(i, x.high)\n\n  var j = x.high\n  while j >= i and x[j-1] < x[i-1]:\n    dec j\n\n  swap x[i-1], x[j]\n\n  result = true\n\nwhen isMainModule:\n  # Tests for lowerBound\n  var arr = @[1,2,3,5,6,7,8,9]\n  assert arr.lowerBound(0) == 0\n  assert arr.lowerBound(4) == 3\n  assert arr.lowerBound(5) == 3\n  assert arr.lowerBound(10) == 8\n  arr = @[1,5,10]\n  assert arr.lowerBound(4) == 1\n  assert arr.lowerBound(5) == 1\n  assert arr.lowerBound(6) == 2\n  # Tests for isSorted\n  var srt1 = [1,2,3,4,4,4,4,5]\n  var srt2 = ["iello","hello"]\n  var srt3 = [1.0,1.0,1.0]\n  var srt4: seq[int]\n  assert srt1.isSorted(cmp) == true\n  assert srt2.isSorted(cmp) == false\n  assert srt3.isSorted(cmp) == true\n  assert srt4.isSorted(cmp) == true\n  var srtseq = newSeq[int]()\n  assert srtseq.isSorted(cmp) == true\n  # Tests for reversed\n  var arr1 = @[0,1,2,3,4]\n  assert arr1.reversed() == @[4,3,2,1,0]\n  for i in 0 .. high(arr1):\n    assert arr1.reversed(0, i) == arr1.reversed()[high(arr1) - i .. high(arr1)]\n    assert arr1.reversed(i, high(arr1)) == arr1.reversed()[0 .. high(arr1) - i]\n\n\nproc rotateInternal[T](arg: var openarray[T]; first, middle, last: int): int =\n  ## A port of std::rotate from c++. Ported from `this reference <http://www.cplusplus.com/reference/algorithm/rotate/>`_.\n  result = first + last - middle\n\n  if first == middle or middle == last:\n    return\n\n  assert first < middle\n  assert middle < last\n\n  # m prefix for mutable\n  var\n    mFirst = first\n    mMiddle = middle\n    next = middle\n\n  swap(arg[mFirst], arg[next])\n  mFirst += 1\n  next += 1\n  if mFirst == mMiddle:\n    mMiddle = next\n\n  while next != last:\n    swap(arg[mFirst], arg[next])\n    mFirst += 1\n    next += 1\n    if mFirst == mMiddle:\n      mMiddle = next\n\n  next = mMiddle\n  while next != last:\n    swap(arg[mFirst], arg[next])\n    mFirst += 1\n    next += 1\n    if mFirst == mMiddle:\n      mMiddle = next\n    elif next == last:\n      next = mMiddle\n\nproc rotatedInternal[T](arg: openarray[T]; first, middle, last: int): seq[T] =\n  result = newSeq[T](arg.len)\n  for i in 0 ..< first:\n    result[i] = arg[i]\n  let N = last - middle\n  let M = middle - first\n  for i in 0 ..< N:\n    result[first+i] = arg[middle+i]\n  for i in 0 ..< M:\n    result[first+N+i] = arg[first+i]\n  for i in last ..< arg.len:\n    result[i] = arg[i]\n\nproc rotateLeft*[T](arg: var openarray[T]; slice: HSlice[int, int]; dist: int): int {.discardable.} =\n  ## performs a left rotation on a range of elements. If you want to rotate\n  ## right, use a negative ``dist``. Specifically, ``rotateLeft`` rotates\n  ## the elements at ``slice`` by ``dist`` positions.\n  ##\n  ## | The element at index ``slice.a + dist`` will be at index ``slice.a``.\n  ## | The element at index ``slice.b`` will be at ``slice.a + dist -1``.\n  ## | The element at index ``slice.a`` will be at ``slice.b + 1 - dist``.\n  ## | The element at index ``slice.a + dist - 1`` will be at ``slice.b``.\n  ##\n  ## Elements outside of ``slice`` will be left unchanged.\n  ## The time complexity is linear to ``slice.b - slice.a + 1``.\n  ##\n  ## ``slice``\n  ##   The indices of the element range that should be rotated.\n  ##\n  ## ``dist``\n  ##   The distance in amount of elements that the data should be rotated.\n  ##   Can be negative, can be any number.\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   var list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  ##   list.rotateLeft(1 .. 8, 3)\n  ##   doAssert list == [0, 4, 5, 6, 7, 8, 1, 2, 3, 9, 10]\n  let sliceLen = slice.b + 1 - slice.a\n  let distLeft = ((dist mod sliceLen) + sliceLen) mod sliceLen\n  arg.rotateInternal(slice.a, slice.a+distLeft, slice.b + 1)\n\nproc rotateLeft*[T](arg: var openarray[T]; dist: int): int {.discardable.} =\n  ## Default arguments for slice, so that this procedure operates on the entire\n  ## ``arg``, and not just on a part of it.\n  runnableExamples:\n      var a = [1, 2, 3, 4, 5]\n      a.rotateLeft(2)\n      doAssert a == [3, 4, 5, 1, 2]\n  let arglen = arg.len\n  let distLeft = ((dist mod arglen) + arglen) mod arglen\n  arg.rotateInternal(0, distLeft, arglen)\n\nproc rotatedLeft*[T](arg: openarray[T]; slice: HSlice[int, int], dist: int): seq[T] =\n  ## Same as ``rotateLeft``, just with the difference that it does\n  ## not modify the argument. It creates a new ``seq`` instead.\n  let sliceLen = slice.b + 1 - slice.a\n  let distLeft = ((dist mod sliceLen) + sliceLen) mod sliceLen\n  arg.rotatedInternal(slice.a, slice.a+distLeft, slice.b+1)\n\nproc rotatedLeft*[T](arg: openarray[T]; dist: int): seq[T] =\n  ## Same as ``rotateLeft``, just with the difference that it does\n  ## not modify the argument. It creates a new ``seq`` instead.\n  let arglen = arg.len\n  let distLeft = ((dist mod arglen) + arglen) mod arglen\n  arg.rotatedInternal(0, distLeft, arg.len)\n\nwhen isMainModule:\n  var list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  let list2 = list.rotatedLeft(1 ..< 9, 3)\n  let expected = [0, 4, 5, 6, 7, 8, 1, 2, 3, 9, 10]\n\n  doAssert list.rotateLeft(1 ..< 9, 3) == 6\n  doAssert list == expected\n  doAssert list2 == @expected\n\n  var s0,s1,s2,s3,s4,s5 = "xxxabcdefgxxx"\n\n  doAssert s0.rotateLeft(3 ..< 10, 3) == 7\n  doAssert s0 == "xxxdefgabcxxx"\n  doAssert s1.rotateLeft(3 ..< 10, 2) == 8\n  doAssert s1 == "xxxcdefgabxxx"\n  doAssert s2.rotateLeft(3 ..< 10, 4) == 6\n  doAssert s2 == "xxxefgabcdxxx"\n  doAssert s3.rotateLeft(3 ..< 10, -3) == 6\n  doAssert s3 == "xxxefgabcdxxx"\n  doAssert s4.rotateLeft(3 ..< 10, -10) == 6\n  doAssert s4 == "xxxefgabcdxxx"\n  doAssert s5.rotateLeft(3 ..< 10, 11) == 6\n  doAssert s5 == "xxxefgabcdxxx"\n\n  block product:\n    doAssert product(newSeq[seq[int]]()) == newSeq[seq[int]](), "empty input"\n    doAssert product(@[newSeq[int](), @[], @[]]) == newSeq[seq[int]](), "bit more empty input"\n    doAssert product(@[@[1,2]]) == @[@[1,2]], "a simple case of one element"\n    doAssert product(@[@[1,2], @[3,4]]) == @[@[2,4],@[1,4],@[2,3],@[1,3]], "two elements"\n    doAssert product(@[@[1,2], @[3,4], @[5,6]]) == @[@[2,4,6],@[1,4,6],@[2,3,6],@[1,3,6], @[2,4,5],@[1,4,5],@[2,3,5],@[1,3,5]], "three elements"\n    doAssert product(@[@[1,2], @[]]) == newSeq[seq[int]](), "two elements, but one empty"\n\n  block lowerBound:\n    doAssert lowerBound([1,2,4], 3, system.cmp[int]) == 2\n    doAssert lowerBound([1,2,2,3], 4, system.cmp[int]) == 4\n    doAssert lowerBound([1,2,3,10], 11) == 4\n\n  block upperBound:\n    doAssert upperBound([1,2,4], 3, system.cmp[int]) == 2\n    doAssert upperBound([1,2,2,3], 3, system.cmp[int]) == 4\n    doAssert upperBound([1,2,3,5], 3) == 3\n\n  block fillEmptySeq:\n    var s = newSeq[int]()\n    s.fill(0)\n\n  block testBinarySearch:\n    var noData: seq[int]\n    doAssert binarySearch(noData, 7) == -1\n    let oneData = @[1]\n    doAssert binarySearch(oneData, 1) == 0\n    doAssert binarySearch(onedata, 7) == -1\n    let someData = @[1,3,4,7]\n    doAssert binarySearch(someData, 1) == 0\n    doAssert binarySearch(somedata, 7) == 3\n    doAssert binarySearch(someData, -1) == -1\n    doAssert binarySearch(someData, 5) == -1\n    doAssert binarySearch(someData, 13) == -1\n    let moreData = @[1,3,5,7,4711]\n    doAssert binarySearch(moreData, -1) == -1\n    doAssert binarySearch(moreData,  1) == 0\n    doAssert binarySearch(moreData,  5) == 2\n    doAssert binarySearch(moreData,  6) == -1\n    doAssert binarySearch(moreData,  4711) == 4\n    doAssert binarySearch(moreData,  4712) == -1')